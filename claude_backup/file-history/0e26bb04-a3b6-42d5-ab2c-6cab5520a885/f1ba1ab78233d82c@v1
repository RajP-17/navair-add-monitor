#!/usr/bin/env python3
"""
Configuration generator for NAVAIR_ADDITIVE system.
Creates initial configuration files with appropriate defaults.
"""

import os
import json
import logging
from pathlib import Path
from typing import Dict, Any

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def generate_settings_config(data_dir: Path) -> Dict[str, Any]:
    """Generate main settings configuration."""
    return {
        "database": {
            "url": f"sqlite:///{data_dir}/database/navair.db",
            "encryption_key_file": f"{data_dir}/keys/db_encryption.key",
            "backup_enabled": True,
            "backup_interval_hours": 24,
            "retention_days": 90
        },
        "sensors": {
            "bme280": {
                "enabled": True,
                "i2c_address": "0x76",
                "polling_interval": 60,
                "calibration_file": f"{data_dir}/calibration/bme280_cal.json"
            },
            "mpu6050": {
                "enabled": True,
                "i2c_address": "0x68",
                "polling_interval": 20,
                "calibration_file": f"{data_dir}/calibration/mpu6050_cal.json",
                "sensitivity": {
                    "accelerometer": 2,
                    "gyroscope": 250
                }
            },
            "laser_arrays": {
                "enabled": True,
                "x_axis": {
                    "serial_port": "/dev/ttyUSB0",
                    "baud_rate": 115200,
                    "sensor_count": 36,
                    "polling_interval": 0.02
                },
                "y_axis": {
                    "serial_port": "/dev/ttyUSB1", 
                    "baud_rate": 115200,
                    "sensor_count": 36,
                    "polling_interval": 0.02
                },
                "z_axis": {
                    "serial_port": "/dev/ttyUSB2",
                    "baud_rate": 115200,
                    "sensor_count": 36,
                    "polling_interval": 0.02
                }
            },
            "printer_api": {
                "enabled": True,
                "base_url": "http://192.168.1.100",
                "api_key": "your_printer_api_key_here",
                "polling_interval": 30,
                "timeout": 10
            }
        },
        "machine_learning": {
            "model_storage": f"{data_dir}/models",
            "feature_window_size": 100,
            "prediction_interval": 60,
            "retrain_interval_hours": 168,
            "materials": {
                "abs": {
                    "temp_range": [210, 250],
                    "bed_temp": 60,
                    "vibration_threshold": 0.5
                },
                "petg": {
                    "temp_range": [220, 250],
                    "bed_temp": 70,
                    "vibration_threshold": 0.3
                },
                "nylon": {
                    "temp_range": [240, 280],
                    "bed_temp": 80,
                    "vibration_threshold": 0.4
                }
            }
        },
        "decision_engine": {
            "rules_file": "config/fmea_rules.json",
            "action_cooldown_seconds": 300,
            "emergency_stop_enabled": True,
            "notification_enabled": True
        },
        "api_server": {
            "host": "0.0.0.0",
            "port": 8000,
            "cors_origins": ["*"],
            "rate_limit": "100/minute",
            "websocket_heartbeat": 30
        },
        "logging": {
            "level": "INFO",
            "file_path": "/var/log/navair_additive/navair.log",
            "max_file_size_mb": 10,
            "backup_count": 10,
            "structured_logging": True
        },
        "monitoring": {
            "metrics_enabled": True,
            "performance_monitoring": True,
            "health_check_interval": 60,
            "alert_thresholds": {
                "cpu_percent": 85,
                "memory_percent": 85,
                "disk_percent": 90,
                "sensor_timeout_seconds": 300
            }
        }
    }

def generate_fmea_rules(config_dir: Path) -> Dict[str, Any]:
    """Generate FMEA-based rules configuration."""
    return {
        "version": "1.0",
        "rules": [
            {
                "rule_id": "temp_runaway",
                "name": "Temperature Runaway Detection",
                "description": "Detects dangerous temperature increases that could cause fire",
                "severity": "EMERGENCY",
                "action": "EMERGENCY_STOP",
                "conditions": [
                    {
                        "sensor": "bme280",
                        "parameter": "temperature",
                        "operator": ">",
                        "value": 80.0,
                        "duration_seconds": 30
                    }
                ],
                "enabled": True
            },
            {
                "rule_id": "layer_shift",
                "name": "Layer Shift Detection", 
                "description": "Detects mechanical layer shifts in print",
                "severity": "HIGH",
                "action": "PAUSE_PRINT",
                "conditions": [
                    {
                        "sensor": "laser_array",
                        "parameter": "geometry_deviation",
                        "operator": ">",
                        "value": 2.0,
                        "duration_seconds": 10
                    }
                ],
                "enabled": True
            },
            {
                "rule_id": "vibration_excessive",
                "name": "Excessive Vibration",
                "description": "Detects harmful vibrations that affect print quality",
                "severity": "MEDIUM",
                "action": "REDUCE_SPEED",
                "conditions": [
                    {
                        "sensor": "mpu6050",
                        "parameter": "vibration_magnitude",
                        "operator": ">",
                        "value": 1.0,
                        "duration_seconds": 60
                    }
                ],
                "enabled": True
            },
            {
                "rule_id": "filament_runout",
                "name": "Filament Runout Detection",
                "description": "Detects when filament runs out during printing",
                "severity": "HIGH", 
                "action": "PAUSE_PRINT",
                "conditions": [
                    {
                        "sensor": "laser_array",
                        "parameter": "filament_present",
                        "operator": "==",
                        "value": False,
                        "duration_seconds": 5
                    }
                ],
                "enabled": True
            },
            {
                "rule_id": "print_detachment",
                "name": "Print Detachment Detection",
                "description": "Detects when print detaches from build plate",
                "severity": "HIGH",
                "action": "PAUSE_PRINT", 
                "conditions": [
                    {
                        "sensor": "laser_array",
                        "parameter": "base_layer_present",
                        "operator": "==",
                        "value": False,
                        "duration_seconds": 30
                    }
                ],
                "enabled": True
            },
            {
                "rule_id": "extruder_clog",
                "name": "Extruder Clog Detection",
                "description": "Detects extruder clogs based on flow patterns",
                "severity": "MEDIUM",
                "action": "NOTIFY_USER",
                "conditions": [
                    {
                        "sensor": "printer_api",
                        "parameter": "flow_rate_variance",
                        "operator": ">",
                        "value": 0.3,
                        "duration_seconds": 120
                    }
                ],
                "enabled": True
            }
        ]
    }

def generate_node_red_settings() -> str:
    """Generate Node-RED settings file."""
    return '''module.exports = {
    // Security settings
    adminAuth: {
        type: "credentials",
        users: [{
            username: "admin",
            password: "$2a$08$zZWtXTja0fB1pzD4sHCMyOCMYz2Z6dNbM6tl8sJogENOMcxWV9DN.", // password
            permissions: "*"
        }]
    },
    
    // Runtime settings
    httpAdminRoot: '/admin',
    httpNodeRoot: '/api/node-red',
    httpStatic: '/opt/navair_additive/node_red/static/',
    
    // Function node settings
    functionGlobalContext: {
        navairApiUrl: "http://localhost:8000/api"
    },
    
    // Logging
    logging: {
        console: {
            level: "info",
            metrics: false,
            audit: false
        }
    },
    
    // Editor settings
    editorTheme: {
        projects: {
            enabled: false
        },
        palette: {
            catalogues: [
                'https://catalogue.nodered.org/catalogue.json'
            ]
        }
    }
};'''

def create_encryption_key(key_file: Path) -> None:
    """Generate encryption key for database."""
    import secrets
    
    key_file.parent.mkdir(parents=True, exist_ok=True)
    key = secrets.token_bytes(32)
    
    with open(key_file, 'wb') as f:
        f.write(key)
    
    # Secure permissions
    os.chmod(key_file, 0o600)
    logger.info(f"Generated encryption key: {key_file}")

def generate_calibration_files(calibration_dir: Path) -> None:
    """Generate default calibration files."""
    calibration_dir.mkdir(parents=True, exist_ok=True)
    
    # BME280 calibration
    bme280_cal = {
        "temperature_offset": 0.0,
        "humidity_offset": 0.0,
        "pressure_offset": 0.0,
        "calibration_date": "2024-01-01T00:00:00Z",
        "calibrated": False
    }
    
    with open(calibration_dir / "bme280_cal.json", 'w') as f:
        json.dump(bme280_cal, f, indent=2)
    
    # MPU6050 calibration
    mpu6050_cal = {
        "accelerometer_offsets": [0.0, 0.0, 0.0],
        "gyroscope_offsets": [0.0, 0.0, 0.0],
        "magnetometer_offsets": [0.0, 0.0, 0.0],
        "calibration_date": "2024-01-01T00:00:00Z",
        "calibrated": False
    }
    
    with open(calibration_dir / "mpu6050_cal.json", 'w') as f:
        json.dump(mpu6050_cal, f, indent=2)
    
    logger.info(f"Generated calibration files in {calibration_dir}")

def main():
    """Main configuration generation function."""
    # Determine paths
    data_dir = Path(os.environ.get('NAVAIR_DATA_DIR', '/var/lib/navair_additive'))
    install_dir = Path(os.environ.get('NAVAIR_INSTALL_DIR', '/opt/navair_additive'))
    
    config_dir = data_dir / 'config'
    keys_dir = data_dir / 'keys'
    calibration_dir = data_dir / 'calibration'
    
    # Create directories
    for directory in [config_dir, keys_dir, calibration_dir]:
        directory.mkdir(parents=True, exist_ok=True)
        logger.info(f"Created directory: {directory}")
    
    # Generate main settings
    logger.info("Generating main settings configuration...")
    settings = generate_settings_config(data_dir)
    with open(config_dir / 'settings.json', 'w') as f:
        json.dump(settings, f, indent=2)
    
    # Generate FMEA rules
    logger.info("Generating FMEA rules configuration...")
    rules = generate_fmea_rules(config_dir)
    with open(config_dir / 'fmea_rules.json', 'w') as f:
        json.dump(rules, f, indent=2)
    
    # Generate Node-RED settings
    logger.info("Generating Node-RED settings...")
    node_red_settings = generate_node_red_settings()
    with open(install_dir / 'node_red' / 'settings.js', 'w') as f:
        f.write(node_red_settings)
    
    # Generate encryption key
    logger.info("Generating encryption key...")
    create_encryption_key(keys_dir / 'db_encryption.key')
    
    # Generate calibration files
    logger.info("Generating calibration files...")
    generate_calibration_files(calibration_dir)
    
    # Set appropriate ownership and permissions
    service_user = os.environ.get('NAVAIR_USER', 'navair')
    if os.geteuid() == 0:  # Running as root
        import pwd
        import grp
        
        try:
            user_info = pwd.getpwnam(service_user)
            uid = user_info.pw_uid
            gid = user_info.pw_gid
            
            for root, dirs, files in os.walk(data_dir):
                os.chown(root, uid, gid)
                for file in files:
                    os.chown(os.path.join(root, file), uid, gid)
            
            logger.info(f"Set ownership to {service_user}:{service_user}")
        except KeyError:
            logger.warning(f"User {service_user} not found, skipping ownership change")
    
    logger.info("Configuration generation completed successfully!")
    print(f"Configuration files created in: {config_dir}")
    print(f"Encryption keys stored in: {keys_dir}")
    print(f"Calibration files created in: {calibration_dir}")

if __name__ == "__main__":
    main()