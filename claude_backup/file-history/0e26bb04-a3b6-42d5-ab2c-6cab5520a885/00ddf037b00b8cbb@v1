"""Ultimaker S5 Printer API Interface for print control and monitoring."""

import asyncio
import logging
from datetime import datetime
from typing import Dict, Optional, Any
from enum import Enum

try:
    import httpx
    HAS_HTTPX = True
except ImportError:
    HAS_HTTPX = False

logger = logging.getLogger(__name__)


class PrinterState(Enum):
    """Printer state enumeration."""
    IDLE = "idle"
    PRINTING = "printing"
    PAUSED = "paused"
    ERROR = "error"
    OFFLINE = "offline"
    PREPARING = "preparing"


class UltimakerS5Interface:
    """
    Interface for Ultimaker S5 printer API.

    Provides methods for:
    - Print status monitoring
    - Print job control (start/stop/pause/resume)
    - Temperature monitoring
    - Position monitoring
    """

    def __init__(
        self,
        printer_ip: str,
        api_port: int = 80,
        timeout: float = 5.0,
        use_digest_auth: bool = False,
        username: Optional[str] = None,
        password: Optional[str] = None
    ):
        """
        Initialize Ultimaker S5 interface.

        Args:
            printer_ip: IP address of the printer
            api_port: API port (default 80)
            timeout: Request timeout in seconds
            use_digest_auth: Enable digest authentication
            username: API username (if auth enabled)
            password: API password (if auth enabled)
        """
        if not HAS_HTTPX:
            raise ImportError("httpx required for printer interface")

        self.printer_ip = printer_ip
        self.api_port = api_port
        self.base_url = f"http://{printer_ip}:{api_port}/api/v1"
        self.timeout = timeout

        # Authentication
        self.use_auth = use_digest_auth
        self.auth = None
        if use_digest_auth and username and password:
            self.auth = httpx.DigestAuth(username, password)

        # Client connection
        self.client: Optional[httpx.AsyncClient] = None
        self._connected = False

        # Cached state
        self._last_status = None
        self._last_update = None

        logger.info(f"Initialized Ultimaker S5 interface for {printer_ip}")

    async def connect(self) -> bool:
        """Establish connection to printer."""
        try:
            self.client = httpx.AsyncClient(
                timeout=self.timeout,
                auth=self.auth
            )

            # Test connection
            response = await self.client.get(f"{self.base_url}/system")
            if response.status_code == 200:
                self._connected = True
                logger.info(f"Connected to Ultimaker S5 at {self.printer_ip}")
                return True
            else:
                logger.error(f"Failed to connect: HTTP {response.status_code}")
                return False

        except Exception as e:
            logger.error(f"Connection error: {e}")
            self._connected = False
            return False

    async def disconnect(self):
        """Close connection to printer."""
        if self.client:
            await self.client.aclose()
            self.client = None
        self._connected = False
        logger.info("Disconnected from printer")

    @property
    def is_connected(self) -> bool:
        """Check if connected to printer."""
        return self._connected and self.client is not None

    async def _request(self, method: str, endpoint: str, **kwargs) -> Optional[Dict[str, Any]]:
        """
        Make HTTP request to printer API.

        Args:
            method: HTTP method (GET, POST, PUT, DELETE)
            endpoint: API endpoint (without base URL)
            **kwargs: Additional arguments for httpx request

        Returns:
            Response JSON data or None on error
        """
        if not self.is_connected:
            logger.warning("Not connected to printer")
            return None

        try:
            url = f"{self.base_url}/{endpoint.lstrip('/')}"
            response = await self.client.request(method, url, **kwargs)

            if response.status_code in (200, 201, 204):
                if response.content:
                    return response.json()
                return {"success": True}
            else:
                logger.error(f"API request failed: {response.status_code} - {response.text}")
                return None

        except httpx.TimeoutException:
            logger.error(f"Request timeout for {endpoint}")
            return None
        except Exception as e:
            logger.error(f"Request error for {endpoint}: {e}")
            return None

    async def get_printer_status(self) -> Optional[Dict[str, Any]]:
        """
        Get current printer status.

        Returns:
            Dict with printer status including:
            - state: current printer state
            - progress: print progress (0-100)
            - time_elapsed: seconds since print started
            - time_total: estimated total print time
        """
        data = await self._request("GET", "/print_job")
        if not data:
            return None

        # Parse Ultimaker response
        status = {
            "state": PrinterState.OFFLINE.value,
            "progress": 0.0,
            "time_elapsed": 0,
            "time_total": 0,
            "job_name": None,
            "timestamp": datetime.utcnow().isoformat()
        }

        if data:
            # Map Ultimaker states to our states
            printer_state = data.get("state", "").lower()
            if printer_state in ("printing", "print"):
                status["state"] = PrinterState.PRINTING.value
            elif printer_state in ("paused", "pause"):
                status["state"] = PrinterState.PAUSED.value
            elif printer_state in ("idle", "ready"):
                status["state"] = PrinterState.IDLE.value
            elif printer_state in ("error", "maintenance"):
                status["state"] = PrinterState.ERROR.value
            else:
                status["state"] = PrinterState.OFFLINE.value

            # Progress and timing
            status["progress"] = data.get("progress", 0.0) * 100  # Convert to percentage
            status["time_elapsed"] = data.get("time_elapsed", 0)
            status["time_total"] = data.get("time_total", 0)
            status["job_name"] = data.get("name", "Unknown")

        self._last_status = status
        self._last_update = datetime.utcnow()

        return status

    async def get_temperatures(self) -> Optional[Dict[str, Any]]:
        """
        Get current hotend and bed temperatures.

        Returns:
            Dict with temperature data:
            - nozzle_temp: current nozzle temperature (째C)
            - nozzle_target: target nozzle temperature (째C)
            - bed_temp: current bed temperature (째C)
            - bed_target: target bed temperature (째C)
        """
        data = await self._request("GET", "/printer/heads/0/extruders/0/hotend/temperature")
        bed_data = await self._request("GET", "/printer/bed/temperature")

        temps = {
            "nozzle_temp": 0.0,
            "nozzle_target": 0.0,
            "bed_temp": 0.0,
            "bed_target": 0.0,
            "timestamp": datetime.utcnow().isoformat()
        }

        if data:
            temps["nozzle_temp"] = data.get("current", 0.0)
            temps["nozzle_target"] = data.get("target", 0.0)

        if bed_data:
            temps["bed_temp"] = bed_data.get("current", 0.0)
            temps["bed_target"] = bed_data.get("target", 0.0)

        return temps

    async def get_position(self) -> Optional[Dict[str, Any]]:
        """
        Get current print head position.

        Returns:
            Dict with position data (X, Y, Z coordinates)
        """
        data = await self._request("GET", "/printer/heads/0/position")

        if not data:
            return None

        return {
            "x": data.get("x", 0.0),
            "y": data.get("y", 0.0),
            "z": data.get("z", 0.0),
            "timestamp": datetime.utcnow().isoformat()
        }

    async def pause_print(self) -> bool:
        """
        Pause current print job.

        Returns:
            True if successful, False otherwise
        """
        logger.info("Pausing print job")
        result = await self._request("PUT", "/print_job/state", json={"target": "pause"})
        return result is not None

    async def resume_print(self) -> bool:
        """
        Resume paused print job.

        Returns:
            True if successful, False otherwise
        """
        logger.info("Resuming print job")
        result = await self._request("PUT", "/print_job/state", json={"target": "print"})
        return result is not None

    async def stop_print(self) -> bool:
        """
        Stop/abort current print job.

        Returns:
            True if successful, False otherwise
        """
        logger.warning("Stopping print job")
        result = await self._request("PUT", "/print_job/state", json={"target": "abort"})
        return result is not None

    async def emergency_stop(self) -> bool:
        """
        Emergency stop - immediately halt all printer operations.

        Returns:
            True if successful, False otherwise
        """
        logger.critical("EMERGENCY STOP triggered")
        # For Ultimaker S5, emergency stop is same as abort
        return await self.stop_print()

    async def get_print_job_info(self) -> Optional[Dict[str, Any]]:
        """
        Get detailed information about current print job.

        Returns:
            Dict with comprehensive job information
        """
        status = await self.get_printer_status()
        temps = await self.get_temperatures()
        position = await self.get_position()

        if not status:
            return None

        job_info = {
            "status": status,
            "temperatures": temps or {},
            "position": position or {},
            "timestamp": datetime.utcnow().isoformat()
        }

        return job_info

    async def health_check(self) -> bool:
        """
        Perform health check on printer connection.

        Returns:
            True if printer is responding, False otherwise
        """
        try:
            if not self.is_connected:
                # Try to reconnect
                return await self.connect()

            # Test with simple system query
            result = await self._request("GET", "/system")
            return result is not None

        except Exception as e:
            logger.error(f"Health check failed: {e}")
            return False
